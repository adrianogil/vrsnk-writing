% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{A Shader-Based Architecture for Virtual Reality Applications on Mobile Devices\thanks{Supported by SIDIA}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Adriano M. Gil \and Thiago S. Figueira}
%
\authorrunning{Adriano Gil \and Thiago Figueira}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{SIDIA Instituto de Ci\^encia e Tecnologia, Manaus, Brazil
\email{\{adriano.gil,thiago.figueira\}@sidia.com}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
As new technologies for CPUs and GPUs are released, games showcase improved graphics, physics simulations, and responsiveness. For limited form-factors such as virtual reality head-mounted displays though, it is possible  to explore alternatives components to harness additional performance such as the GPU. This paper introduces a shader-based architecture for developing games using shared resources between the CPU and the GPU.

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\section{Introduction}

% TODO: Importance of VR
Virtual reality (VR) brings the promise of a revolution in the way entertainment is consumed in present times. The user is placed at the center of the action and perceives content from every direction.

% TODO: Performance issues games
Games, for their part, transport players to a world envisioned by game designers and developers. As the technology for other form factors such as PC and console advances, VR players want life-like graphics and improved responsiveness.

% TODO: Game architectures
Modern mainstream game consoles and PC sets allow parallel computing to be performed. In order to harness this extra computing power, it is necessary to move tasks from the single threaded game loop and place the ones that can run in parallel in different processors.

% TODO: Reasons/Motivation for a Shader-based architecture
VR devices, on the other hand, have a limited form factor. Issues like the heat generated by the processing components have to be taken into account which means adding more computing power is not possible without having side effects for the final user through the current form factor.

% TODO: Importance of Unity
In VR games development, the most used game engine is \textit{Unity} \cite{Unity} and even though it is optimized, we believe there is an opportunity in exploring graphics cards for additional performance.

% TODO: Proposal
In this work, we propose an implementation of the classic game Snake using a shader-based architecture. By using a logic based of parallel execution we achieved a very performatic virtual reality application in which every visual element is defined and rendered by the shader in a unique mesh.

% TODO: Sections
Related research is explored in section \ref{sec:related-works}. An explanation about the game is provided in \ref{sec:vrsnake}. Important concepts for this topic Game Loop and Game Architecture are explored in \ref{sec:game-loops} and \ref{sec:game-architecture}. The proposed architecture is explained in section \ref{sec:proposed-architecture}. At the end, results are in section \ref{sec:results}.


\section{Related Work} \label{sec:related-works}

The literature is scarce about approaches using GPU development for Virtual Reality though there are some initiatives in mobile and computer environments.

% TODO: Refs for VR Games, highlight performance/architecture concepts

% TODO: Refs for Games running only on GPU
The two-dimensional game \textit{GPGPUWars} \cite{joselli2009gpuwars} has its code structure based on \textit{shaders}, similar to the architecture presented here where the GPU performs all the processing of the game. The mobile game MobileWars is a massive 2D shooter with top-down perspective \cite{MobileWars} which uses the GPU to process the game logic and the CPU for the data acquisition step. However, applications in virtual reality differ from other applications because there is the need to fill the three-dimensional space to provide content for 3 degrees of freedom (3DoF-\textit{3 Degrees of Freedom}). For example, the application described in \cite{zund2015unfolding} uses computational vision to generate a panoramic view of an 8-bit console game.

% TODO: Refs for Games architectures
Some works explore different game architectures: AlienQuiz Invaders \cite{Loop2012}, for example, is an augmented reality game that implements cloud services to improve overall game quality. \cite{MobileWars}, \cite{joselli2009gpuwars}, \cite{GameArchitecture2009} explore the GPU for performance in mobile and PC environments.


% TODO: Refs for GPU-based architectures


\section{The game - VRSnake} \label{sec:vrsnake}
% TODO: Describe rules of the game
VRSnake is the virtual reality version of the classic 2D game Snake.
In the original game, the player moves the snake to collect the elements that appear randomly during gameplay. In its virtual reality adaptation, VRSnake, the player decides where to position the collectable items rather than directly controlling the snake. In other words, the player stands in the center of the game world surrounded by the inverted sphere where the snake moves.
For this new game-play design, we defined the following rules:

\begin{enumerate}
\item The player sets the collectible object position;
\item The snake continuously and automatically seeks the collectable object placed by the player and grows in a unit when it reaches this object;
\item The victory condition is making the snake hit itself during the pursuit for the object.
\end{enumerate}

\section{Game Loops} \label{sec:game-loops}
% Example of default game loop architecture
The game loop is the foundation which upon games are built. Games are considered real-time applications because their tasks rely on time constraints. According to \cite{GameArchitecture2009}, these tasks can be arranged into three steps: data acquisition, data processing and presentation. The first step is about collecting input data from the input devices (for VR devices, it is the Head-Mounted Display (HMD) and the joysticks); the second step is applying player input into the game as well as game rules and other simulation tasks; the last step is providing to the user the current game state through visual and audio updates.

There are two main groups of loop models proposed by \cite{valente_conci_feijo}: the coupled model and the uncoupled model.
In the simplest approach, all steps are executed sequentially and it runs as fast as the machine is capable of. The uncoupled model separates rendering and update steps in different threads, but this may cause the same unpredictable scenario of the Coupled Model when executed in different machines. The Multi-thread Uncoupled Model feeds the update stage with a time parameter to adjust its execution with time and allow the game to behave in the same way in different machines.

Due to its interactive nature, these steps should be performed as fast as possible in games or performance may jeopardize user experience. For VR applications, this constraint is even heavier as VR games should run at 60 frames per second \cite{pruett_2015} to avoid nausea and other negative user effects, this is why Virtual Reality software requires powerful CPU and GPU hardware \cite{gregory_2019}.

Modern mainstream game consoles and PC sets allow parallel computing to be performed. In order to harness this extra computing power, it is necessary to move tasks from the single threaded game loop and place the ones that can run in parallel in different processors.

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[height=5cm]{src/hci2020-images/CoupledLoopModel.jpg}
        \caption{Coupled Model}
        \label{fig:coupledModel}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
        \centering
        \includegraphics[height=5cm]{src/hci2020-images/UncoupledLoopModel.jpg}
        \caption{Multi-thread Uncoupled Model \cite{valente_conci_feijo}}
        \label{fig:uncoupledModel}
    \end{minipage}
\end{figure}


\section{Game architectures} \label{sec:game-architecture}
% TODO: What is a game architecture?
Games are a  software product, therefore the  architecture of a game is comparable to that of software and defines how the game is built. Usually, it is not apparent to the player, except for performance \cite{croft_2004}.

According to \cite{mcshaffry_2009}, it is possible to classify any sub-system in a game in one of the three categories (see figure \ref{fig:highArchitecture}): the application layer, the logic layer, and the game view layer. The first layer deals with the operating system and hardware. The second layer manages the game state and how it changes over time. The game view layer presents the current game state with the graphics and sound outputs.

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.5]{src/hci2020-images/GameArchitecture.jpg}
    \caption{High-level game architecture}
    \label{fig:highArchitecture}
\end{figure}

Game engines provide \textit{"software that is extensible and can be used as the foundation for many different games without major modification"} \cite{gregory_2019}, and as such, they encapsulate the general game architecture (see figure \ref{fig:Simplified_game_engine}).

\begin{figure}[!h]
    \centering
    \includegraphics[scale=0.5]{src/hci2020-images/GameEngineArchitecture.jpg}
    \caption{Simplified view of a game engine architecture}
    \label{fig:Simplified_game_engine}
\end{figure}

The game engine is responsible for the Update Thread, the Draw Thread and the Game Objects. Each correspond to a general step defined in the general game architecture. The Game Objects are the items the player may or may not interact with during game-play. The Update Thread  is responsible for updating game objects as far as it can whereas the Draw Thread updates all elements visually on the output device \cite{portales}.

% TODO: Objectives of a game architecture?
Game architectures can be updated to better reflect the needs of the game. A well-defined architecture enables better performance and overall results with the final game. In fact, most game engines (as well as the architectures behind it) are crafted for specific platforms and, in some cases, for particular games \cite{gregory_2019}.

\subsection{Proposed Architecture} \label{sec:proposed-architecture}
% Our proposal - Two layers
We propose a game architecture based on two layers:
% Logic layer
one layer handles the game logic whereas the other manages rendering.  The logical layer is CPU-bound and has tasks such as the search for the collectible objects and snake movement.

\begin{figure}
    \centering
    \begin{minipage}[b][6cm][b]{.5\textwidth}
        \centering
        \includegraphics[height=3cm]{hci2020-paper/images/VRSnake_Proposed_Architecture.png}
        \caption{Logic layer runs on CPU}
        \label{fig:coupledModel}
    \end{minipage}%
    \begin{minipage}[b][6cm][b]{.5\textwidth}
        \centering
        \includegraphics[height=5cm]{hci2020-paper/images/VRSnake_Proposed_Architecture2.png}
        \caption{Both logic and visualization layers runs on GPU}
        \label{fig:uncoupledModel}
    \end{minipage}
\end{figure}

% Render layer
The visualization layer involves a shader, a piece of code that runs in the Graphics Processing Unit (GPU), that renders all game objects on the output device, which includes the collectible objects as well as the snake.

\begin{figure}
    \centering
    \begin{minipage}[b][6cm][b]{.5\textwidth}
        \centering
        \includegraphics[height=3cm]{hci2020-paper/images/VRSnake_Proposed_Architecture.png}
        \caption{Logic layer runs on CPU}
        \label{fig:coupledModel}
    \end{minipage}%
    \begin{minipage}[b][6cm][b]{.5\textwidth}
        \centering
        \includegraphics[height=5cm]{hci2020-paper/images/VRSnake_Proposed_Architecture2.png}
        \caption{Both logic and visualization layers runs on GPU}
        \label{fig:uncoupledModel}
    \end{minipage}
\end{figure}

In other words, the logical layer manages the collision and movement of the snake and selects the most promising path given a randomization factor; The visualization layer renders all the elements arranged in the output device, the CPU does not influence these objects.

Our implementation is based on pixel shaders since we want to guarantee support for Android-based VR platform that don't have support for more specialized shader types, like computer shaders for instance.

\section{Visualization layer}
\label{sec:visualization-layer}
The visualization layer has the code necessary to make game elements visible to the user. In the proposed architecture, the visualization layer is based entirely on a pixel shader running in a single mesh.


Given a logical texture, i.e. a texture representing the current game state, the centralized pixel shader must render the position of each game element: snakes and food. The role of the visualization layer is to represent the game element according to a style: 2D or 3D for instance. In this work, we implemented a 2d representation on a sphere and a raymarched visualization on a cube. However many others are possible, like using particles for example.


The following subsections explain how snakes in VRSnake are drawn. Subsection \ref{subsec:rendering-snakes} explains the general method, whereas the others explore the specifics such as inverted spheres (subsection \ref{subsec:inverted-sphere}), 2d shader snakes (subsection \ref{subsec:2d-snakes}) and ray-marched snakes (subsection \ref{subsec:raymarching-snakes}).

\subsection{Rendering VR snakes}
\label{subsec:rendering-snakes}
Shaders are scripts that carry the mathematical calculations and algorithms to compute the color of each pixel rendered on the output device. For 2D and 3D snake rendering, the shader in the visualization layer requires an external texture that contains the logical information needed to draw the final image.

\subsection{Virtual reality in a inverted sphere}
\label{subsec:inverted-sphere}
The immersion sense that comes with virtual worlds requires visual information available from all angles. Given that our proposition considers a 2D game, the challenge is displaying two-dimensional content in a 3D scenario with the user at the center.

An inverted sphere, a sphere that has only its inner side rendered, makes it possible to fill the entire field of view, it also is the endorsed solution to display equirectangular images in 360 degrees. The procedural generation of a sphere can follow one of the two approaches below:

\begin{enumerate}
  \begin{item} An icosphere, i.e., a sphere which vertices are evenly distributed;
 \end{item}
  \begin{item} Generation of vertices based on longitude/latitude coordinates. \end{item}
\end{enumerate}

For this work, the second approach was adopted due to the possibility of using longitude/latitude as a way to map the UV coordinates through the equation below:

\begin{equation}
R^2 \leftarrow R^3 : (\lambda, \theta) \rightarrow (x, y, z)
\label{equation1}
\end{equation}

% 2 - Mapeamento de UV em uma esfera invertida
To calculate the positions of the sphere vertices, given $N_{latitude}$ latitude values  and $N_{longitude}$ longitude values, the value $R_{longitude}$ is defined as the angular longitude size of a cross-section of the sphere, as seen in the equation \ref{equation1}.

\begin{equation}
R_{longitude} = \frac{2 \pi}{N_{longitude}}
\label{equation1}
\end{equation}

The total angular size of an amount of $i$ of longitude values can be given by the equation \ref{equation2}.

\begin{equation}
\alpha_{i} = i * R_{longitude}
\label{equation2}
\end{equation}

Equations \ref{equation3} and \ref{equation4} define the X and Z positions of sphere points belonging to a cross section of the sphere that has radius $D$.

\begin{equation}
x_{i} = D * \sin(\alpha_{i})
\label{equation3}
\end{equation}

\begin{equation}
z_{i} = D * \cos(\alpha_{i})
\label{equation4}
\end{equation}

In a longitudinal cut, it is possible to notice that the radius $D$ of the cross section is variable along the height of the sphere. It is then determined a value $R$ as the angular size of a latitude value of the sphere, as seen in the equation \ref{equation5}.

\begin{equation}
R_{latitude} = \frac{\pi}{ N_{latitude}}
\label{equation5}
\end{equation}

The total angular size of an amount of $i$ of latitude values can be given by the equation \ref{equation6}.

\begin{equation}
\alpha_{latitude} = i * R_{latitude}
\label{equation6}
\end{equation}

The Y position of the sphere points, considering unit radius, can be given by the equation \ref{equation7}.
\begin{equation}
y_{i} = \cos(\alpha_{latitude})
\label{equation7}
\end{equation}

The radius $D_{yi}$ obtained in a cross section at latitude $i$ is defined in the equation \ref{equation8} as:
\begin{equation}
D_{yi} = 2 * \sin(\alpha_{yi})
\label{equation8}
\end{equation}

By applying the equation \ref{equation8} in the equations \ref{equation3} and ref{equation4} the X and Z positions of the sphere vertices are obtained according to their longitude and latitude coordinates.

\begin{equation}
x_{i} = 2 * \sin(\alpha_{latitude}) * \sin(\alpha_{longitude})
\label{equation9}
\end{equation}

\begin{equation}
z_{i} = 2 * \sin(\alpha_{latitude}) * \cos(\alpha_{longitude})
\label{equation10}
\end{equation}

% Need to be reviewed
Equations \ref{equation8}, \ref{equation9} and \ref{equation10} allow to define a vector $P_i$ with components $(x_i, y_i, z_i)$ for each uv position. By using all those equations we can find all the vertice positions of a procedural sphere.

\subsection{Simple 2D Snakes}
\label{subsec:2d-snakes}
In VRSnake, the shader responsible to render the snake requires an external texture that defines the current game state. This texture as well as other game elements such as snake color and game background can be defined in the user inspector in Unity (see figure \ref{fig:snake_editor_unity}).

\begin{figure}[!h]
    \centering
    \includegraphics[scale=1]{src/hci2020-images/SnakeTextureMaterial.png}
    \caption{Snake rendering shader in Unity Editor}
    \label{fig:snake_editor_unity}
\end{figure}

The external texture is managed by the logic layer (c\# code), which updates the snake during the update loop of the game. The shader layer sweeps this texture and gathers the red parameter of the RGB color system. The shader reads those values and converts each pixel to screen information according to arbitrary value ranges as seen below:

\begin{itemize}
  \item Between 0 - 0.25 - Draws the head of the snake
  \item Between 0.26 - 0.5 - Draws the body of the snake
  \item Between 0.51 - 0.75 - Draws the collectible object
  \item Between 0.76 - 1 - Draws the background
\end{itemize}

\subsection{Raymarching Cube-based 3D Snakes}
\label{subsec:raymarching-snakes}
% Explaining what is Raymarching
aymarching is an iterative approach for rendering a scene. In each iteration, a ray moves through a line towards a fixed direction and only stops when it reaches an object. Differently from raytracing, it is not necessary to calculate the intersection point between a line and a geometric model. It should be calculated only if the the current point is in the geometric model.

Using signed distance function (SDF) techniques \cite{hart1996sphere}, it is possible to find the distance from the current point position until the target geometry. By means of SDFs, it is possible to accelerate the iterations of raymarching by jumping straight to right position of the intersected geometry.

Our proposal can also be implemented as fake 3D objects rendered by pixel shaders in a plane mesh. We employed raymarching to render cube-based 3D snakes inside a real cube.

\section{Logic layer}

The logic layer is responsible for handling user input and its correspondent actions inside the game virtual word. Thus it is necessary to model how the game works. In VRSnake, the snake modeling includes how it moves and how it interacts with each game element.

In VRSnake, the user input is based on an external joystick. As a sensor, however, these controllers are subject to noisy interference during the virtualization of the event represented in the real world by the user's movement. In order to improve the signal capture and translate the player's intentions more faithfully, the Kalman filter \cite{KalmanComponent} is applied to the readings of the joystick events.


\subsection{Managing Game Objects}

Our framework is based on managing objects data that are rendered by pixel shaders. Thus  we made use of textures to store logic data, that we named as logical textures. Each call of pixel shader should localize the right position of the data inside the logical texture. One of the disadvantages of such method is more expensive to spread big changes.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{hci2020-paper/images/VRSnake_GameObjectData_Management.png}
\caption{Our proposed data management approach for game elements}
\label{fig:VR_GameObjectData_Management}
\end{figure}

\subsection{Snake movement agent} \label{sec:agent}
The movement of the snake is managed by a state evaluation function that analyzes each possible action at any given time. In essence, the serpent is always seeking  the collectible objects, so it evaluates the shortest distance course in the X and Y axes in UV space and, provided that there is no possibility of hitting itself, proceeds through this path and repeats the process. The function below illustrates this procedure:

\begin{equation}
F(A) = R * (D + O)
\label{equation11}
\end{equation}

Where \textit{R} is a randomization factor; \textit{D} represents the \textit{Manhattan} distance between the current position and the collectable object; And \textit{O} is a value attributed to the existence or not of obstacles in this path.

\section{Experiments and Results} \label{sec:results}

The Snake game was developed for virtual reality in the Unity engine. Figure \ref{fig:VRPerformanceChart}  illustrates the frame rate in the GearVR through the Oculus performance assessment tool, the \textit{OVR Metrics Tool} \cite{ovrmetrictool}:

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{src/hci2020-images/VRPerformance.png}
\caption{Frames-per-second recored by the OVR Metrics Tool}
\label{fig:VRPerformanceChart}
\end{figure}

The application presented an average frame-rate of 43.96 fps (frames-per-second), with a minimum of 16 fps and maximum of 60 fps. As represented by the figure \ref{fig:VRPerformanceChart}, the application does not maintain 60 fps and this is most likely due to the kalman filter implementation in the data collection step of the game loop and the garbage collector.

% TODO: Define metrics to evaluate architectures
% TODO: Experiment with normal game
% TODO: Experiment with shader-based game
% TODO: Experiment with VR shader-based game
% TODO: Experiment with shader-based game with Raymarching

\section{Conclusions}
We believe it is possible to explore the GPU for additional performance of virtual reality games in mobile devices. The architecture defined here can be explored as an additional tool for developers to complement the way the game looks and manage resources of VR applications. For future work, we see an opportunity to bring the steps currently present in the logic layer to the visualization layer, further exploring the GPU. We also envision bringing machine learning techniques to the visualization layer to allow multiple snakes to share the same space thus increasing game difficulty. There is the possibility of further improving performance through optimizations to the input gathering implementation as well.
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{shaderbasedarch}
\end{document}
