\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, shapes.geometric}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{VRSnake: Aplicação do Filtro de Kalman em um Jogo de Realidade Virtual com Visualização Baseada em Shader}

\author{Thiago S. Figueira\inst{1}, Adriano M. Gil\inst{1} }

\address{Samsung Instituto de Desenvolvimento para a Informática da Amazônia
  (SIDIA)\\
  Manaus -- AM -- Brazil
  \email{\{t.figueira,adriano.gil\}@samsung.com}
}

\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  resumos de artigos para publicação nos anais das conferências organizadas
  pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  página do artigo.
\end{resumo}


\section{Introdução}

A realidade virtual (VR, em inglês) tem angariado a atenção do mercado de jogos como forma de entretenimento cada vez mais plausível para o consumidor final à medida que novos \textit{head mounted displays} (HMDs) e dispositivos \textit{VR-Ready} são disponiblizados. Com a popularização da tecnologia, a qual promete imersão em mundos realistas, os desenvolvedores enfrentam desafios tecnológicos relacionados ao aproveitamento do poder computacional do dispositivo, tendo em vista cumprir a entrega da experiência prometida. 
Pelas lentes do desenvolvimento, a \textit{Unity} situa-se como peça de extrema relevância dadas a sua facilidade de aprendizado, gratuidade do uso e interatividade entre a comunidade de criadores.

Normalmente, os jogos desenvolvidos na Unity são compostos por conjuntos de cenas, cada qual com seu próprio agrupamento de objetos e lógica associados. As unidades gráfica e central de processamento têm papeis bem definidos, no entanto, devido à natureza de aplicação clássica, a maior parte do comportamento lógico e de controle de objetos está associado à unidade central de processamento. Em outro aspecto, os controladores para dispositivos de realidade virtual, em especial o \textit{joystick}, são passíveis de ruídos devido à sua natureza sensorial, o que implica  em comportamentos indesejados como \textit{jittering} durante a leitura dos dados e, por conseguinte, impedimento do nível adequado de responsividade em um jogo. 

Desse modo, propõe-se o desenvolvimento de um jogo cujas representações gráficas sejam inteiramente fundamentadas em código de GPU ao passo que as restrições lógicas concentrem-se na CPU. Em alusão à um clássico, o jogo Serpente (ou Snake, de 1979) será recriado para os dispositivos de realidade virtual da Samsung em uma aplicação Unity, diferencia-se, porém, na medida que o jogador controla o objeto coletável, posicionando-o com a finalidade de fazer a serpente falhar em seu objetivo. No que se refere ao controlador, intenta-se a aplicação do filtro de Kalman durante a leitura do posicionamento do cursor, a fim de melhorar o reconhecimento do sinal e  atenuar esta inconsistência.

\section{Trabalhos Relacionados}

\section{Arquitetura de Visualização Baseada em Shader}
Há essencialmente duas camadas respectivamente responsáveis pela renderização e gerenciamento lógico da aplicação. A primeira é um shader, código executado diretamente na unidade de processamento gráfico, incumbido de delinear (ou renderizar) todos os itens apresentados no dispositivo de saída, que incluem o objeto coletável circular bem como os quadriláteros que representam o personagem ou a \textit{snake}. A segunda camada, executada na unidade central de processamento, é encarregada das tarefas mais inteligentes tais como a busca pelo objeto coletável e consequente movimentação. Faz-se necessário, portanto, explorar o funcionamento das etapas desenvolvidas, mencionadas acima. 

Para a movimentação da serpente, basta que o objeto original, ou figurativamente, a cabeça, seja movimentado na direção pretendida. À medida que o número de partes do corpo da \textit{snake} é acrescido, estas também são movimentadas ao assumir a posição da parte imediatamente anterior. Durante a movimentação da cabeça, são traçados três vetores que apontam, nessa ordem, para cima, para baixo e para frente e, portanto, são responsáveis por orientar a serpente na decisão do menor caminho entre sua atual posição e o objeto coletável. Considerando a restrição de deslocamento na qual pode-se mover unicamente nas referidas direções, o cálculo por meio da distância de Manhattan se mostrou mais apropriado. É relevante explicitar que os vetores de direcionamento são mutáveis, tendo em vista as possíveis posições assumíveis em dado momento.  

O \textit{shader}, por sua vez, determina a relação de domínio (ou pertencimento) de cada pixel, em outras palavras, verifica-se um a um a que elemento gráfico o pixel pertence, o que pode ser, no universo desta aplicação, o objeto coletável, ou uma parte da serpente ou ainda o próprio plano de fundo. Para determinar esta relação de atribuição, alguns cálculos básicos são necessários. A exemplo, um pixel é colorido com a cor do objeto coletável se sua distância até o centro do objeto for menor que o raio à medida que o mesmo pixel recebe a cor da serpente, caso esteja contido na área do quadrilátero, dados o tamanho do lado e centro. 
O diagrama abaixo ilustra o funcionamento da arquitetura. 

\begin{figure}[H]
\centering
\tikzstyle{arrow} = [draw, -latex]

\begin{tikzpicture} [x=1.2cm, y=1cm, node distance=0,outer sep=0,inner sep=0]
	\draw (0, 0) rectangle (12,4);
	\draw[dashed] (6,0) -- (6,4);	
	
	\draw (0,3.5) rectangle (6,4) node[pos=.5] {\small Camada Lógica (CSharp)};
	\draw (6, 3.5) rectangle (12, 4) node[pos=.5] {\small Camada de Visualização (Shader)};
	
	\draw (0.3, 2.7) rectangle (4, 3.2) node[pos=.5] (1A) {\small Gerenciamento de Colisão};
	\draw (0.6, 1.9) rectangle (4.6, 2.4) node[pos=.5] (2A) {\small Movimentação da Serpente};
	\draw (7, 1.9) rectangle (11, 2.4)node[pos=.5] (3A) {\small Renderização da Serpente};
	
	\draw (0.3, 1) rectangle (4.3, 1.5) node[pos=.5] (4A) {\small Aplicação do filtro de Kalman};
	\draw (0.6, 0.2) rectangle (5.6, 0.7) node[pos=.5] (5A) {\small Cálculo da Geometria do Background};
	\draw (7, 0.2) rectangle (11, 0.7) node[pos=.5] (6A) {\small Renderização do Background};	
	
	
	\path [arrow] (1A) -- (2A);
	\path [arrow] (2A) -- (3A);

	\path [arrow] (4A) -- (5A);
	\path [arrow] (5A) -- (6A);
	
\end{tikzpicture}
\caption{Diagrama de arquitetura da aplicação}
\end{figure}

\section{Uso do Controle VR com Filtro de Kalman}
Para a interação humano-computador de dispositivos de realidade virtual (VR), existem essencialmente duas formas de interação com o cursor: o HDM (\textit{head-mounted display}), ou seja, um sensor lateral acoplado ao próprio dispositivo, e os controladores externos, como os controles ou \textit{joysticks}. Em sua condição de sensor, estes controladores estão sujeitos à interferência ruidosa durante a virtualização do evento representado no mundo real pelo movimento do usuário. Com a finalidade de melhorar a captura do sinal e traduzir de maneira mais fiel as intenções do jogador, o filtro de Kalman será aplicado às leituras do \textit{joystick} por meio de um componente de visualização de ruídos e aplicação do filtro desenvolvido por [].

\section{Trabalhos Futuros}\label{sec:figs}
Em trabalhos futuros, dois passos são vistos como cruciais. Em primeiro lugar, migrar inteiramente os processos da camada lógica para a camada de visualização, na unidade gráfica de processamento, com o propósito de permitir o controle e exibição de um número representativamente maior de serpentes. Em segundo lugar, aplicar aprendizagem de máquina nesta camada, objetivando-se um comportamento de busca e desvio de obstáculos (como outras serpentes e seu próprio corpo) mais inteligente, por conseguinte, desafiador.

\section{References}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
