\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage{float}
\usepackage{tikz}
%\usetikzlibrary{shapes, arrows, shapes.geometric}
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{VRSnake: Aplicação do Filtro de Kalman em um Jogo de Realidade Virtual com Visualização Baseada em Shader}

\author{Thiago S. Figueira\inst{1}, Adriano M. Gil\inst{1} }

\address{Samsung Instituto de Desenvolvimento para a Informática da Amazônia
  (SIDIA)\\
  Manaus -- AM -- Brazil
  \email{\{t.figueira,adriano.gil\}@samsung.com}
}

\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  resumos de artigos para publicação nos anais das conferências organizadas
  pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  página do artigo.
\end{resumo}


\section{Introdução} \label{sec:introduction}
% Contextualizar a Realidade Virtual e Controladores
A realidade virtual (VR, em inglês) tem angariado a atenção do consumidor final à medida que são disponibilizados no mercado novos \textit{head mounted displays} (HMDs) e dispositivos  munidos do poder computacional para a execução de aplicações VR, juntamente com seus respectivos controladores.  Estes últimos, contudo, são passíveis de ruídos devido à sua natureza sensorial, o que implica  em comportamentos indesejados como \textit{jittering} durante a leitura dos dados.  

% Contextualizar a Unity
No desenvolvimento de aplicações VR, o motor e editor gráfico (\textit{engine}) \textit{Unity} situa-se como peça de extrema relevância dadas a sua facilidade de aprendizado e incomplexidade no processo de desenvolvimento. 

Normalmente, os jogos e aplicações desenvolvidos na Unity são compostos por conjuntos de cenas, cada qual com seu próprio agrupamento de objetos e lógica associados. Desta maneira, a CPU é responsável por transmitir informações sobre elementos gráficos à GPU. Este processo acontece em dois estágios, primeiro os \textit{assets} gráficos como modelos e texturas são carregados na VRAM (\textit{video RAM}) e posteriormente a CPU diz à GPU o que fazer, à medida que descreve os diferentes objetos renderizados na tela, como onde eles estão e outras informações relevantes. Por sua vez, a GPU recolhe esta informação e a converte em imagem.  

% Resumo proposta
Desse modo, propõe-se o desenvolvimento de um jogo cujas representações gráficas sejam inteiramente fundamentadas em código de GPU ao passo que as restrições lógicas concentrem-se na CPU, de maneira a aliviar o trabalho desta última. Em alusão à um clássico, o jogo Snake, de 1979, será recriado para os dispositivos de realidade virtual da Samsung em uma aplicação Unity, diferencia-se, porém, na medida que o jogador controla o objeto coletável, posicionando-o com a finalidade de fazer a serpente falhar em seu objetivo. Neste aspecto, intenta-se a aplicação do filtro de Kalman durante a leitura do posicionamento do cursor através do \textit{joystick}, a fim de melhorar o reconhecimento do sinal e atenuar a inconsistência apresentada. 

% * Estrutura do artigo
Analisa-se na seção \ref{sec:relatedworks} outros trabalhos que abordam sensores, uso de filtros e jogos de realidade virtual. Apresentamos como um jogo de realidade virtual pode ser renderizado em uma esfera invertida na seção \ref{sec:invertedsphere}. Um esclarecimento sobre as regras do jogo desenvolvido pode ser encontrado na seção \ref{sec:vrsnake}. A arquitetura proposta é detalhada na seção \ref{sec:architecture}. A seção \ref{sec:gearvrcontroller} explana como ocorre a aplicação do filtro de Kalman no controle para VR. Resultados são discutidos na seção \ref{sec:results}. E por fim pautam-se as conclusões e perspectivas de trabalhos futuros na seção \ref{sec:conclusion}.

\section{Trabalhos Relacionados} \label{sec:relatedworks}

\section{Realidade Virtual em uma Esfera Invertida} \label{sec:invertedsphere}

\section{VRSnake} \label{sec:vrsnake}
% Definição das regras do jogo
O \textit{VRSnake} traz para a realidade virtual o clássico jogo 2D \textit{Snake}, de 1979, mas diferentemente deste, o jogador assume controle sobre o posicionamento dos objetos coletáveis ao invés de controlar diretamente a serpente. Algumas regras precisam ser observadas: em primeiro lugar, a serpente busca contínua e automaticamente o objeto coletável e cresce em uma unidade à medida que alcança este objeto. 

Como no jogo original, a serpente deve movimentar-se de maneira circular pelo cenário, isto é, ao encontrar os limites do cenário de um lado, deve continuar do outro na mesma maneira. O jogador vence quando a \textit{snake} é derrotada, ou seja, quando ela atinge a si própria de alguma forma. 

Além disso, o comportamento de busca da serpente deve garantir que não haja movimentação em direção a seu próprio corpo, mas também a existência de um fator de randomização durante o movimento, tendo em vista garantir a imprevisibilidade deste ato.

\section{Arquitetura de Visualização Baseada em Shader} \label{sec:architecture}
Propõe-se uma arquitetura de duas camadas respectivamente responsáveis pelo gerenciamento lógico e visualização (ou renderização) da aplicação. A primeira fora desenvolvida em \textit{csharp}, portanto executada na unidade central de processamento (CPU - \textit{central processing unit}), e encarregada das tarefas inteligentes tais como a procura pelo objeto coletável e movimentação. A segunda camada envolve um shader, código executado diretamente na unidade de processamento gráfico (GPU - \textit{graphics processing unit}), incumbido de delinear (ou renderizar) todos os itens apresentados no dispositivo de saída, que incluem plano de fundo, o objeto coletável circular bem como os quadriláteros que representam o personagem ou a \textit{snake}. 

\section{Snake como um Agente Utilitário} \label{sec:agent}
A inteligência de movimentação da \textit{snake} é, por sua vez, composta por uma função utilitária que avalia cada possível ação em determinado momento. Em essência, a serpente sempre está buscando alcançar o coletável, por isso avalia a menor distância nos eixos X e Y e, desde que não seja ela mesma um obstáculo neste menor caminho, ela assume esse curso e repete o processo. A função abaixo ilustra esse procedimento:

\begin{equation}
F(A) = R * (D + O)
\end{equation}

Onde R é um fator de randomização; D representa a distância de \textit{Manhattan} entre a posição atual e o objeto coletável; e O é um valor atribuído à existência ou não de obstáculos neste trajeto.

Para cada direção plausível, apresentadas na figura \ref{fig:snakeHeadPositions}, abaixo, a função retorna um valor de utilidade que é ulteriormente comparado para determinar o caminho de maior probabilidade de sucesso.

A movimentação, responsabilidade da primeira camada, pode ser definida como um \textit{buffer} deslizante: à medida que o número de partes do corpo da \textit{snake} é acrescido, estas também são movimentadas ao assumir a posição da parte imediatamente anterior. Logo, a movimentação do primeiro quadrilátero, ou figurativamente, a cabeça, norteia todo o movimentar da \textit{snake}, pois é neste momento que são traçados três vetores que apontam, nessa ordem, para cima, para baixo e para frente e, portanto, são responsáveis por orientar a serpente na decisão do menor caminho entre sua atual posição e o objeto coletável. É relevante explicitar que os vetores de direcionamento são volúveis tendo em vista as diferentes posições adotáveis, conforme a figura \ref{fig:snakeHeadPositions}, abaixo, onde a seta em vermelho indica a atual direção da serpente e as demais indicam possíveis direções de movimento.

\begin{figure}[H]
\centering
\tikzstyle{arrow} = [draw, -latex]

\begin{tikzpicture} [x=1.2cm, y=1cm, node distance=0,outer sep=0,inner sep=0]
	\draw (0, 0) rectangle (1, 1) node[pos=.5] {\small Head};
	\draw (3, 0) rectangle (4, 1) node[pos=.5] {\small Head};
	\draw (6, 0) rectangle (7, 1) node[pos=.5] {\small Head};
	\draw (9, 0) rectangle (10, 1) node[pos=.5] {\small Head};
	
	\path [arrow, red] (0.5, 1) -- (0.5, 1.5);
	\path [arrow] (1, 0.5) -- (1.5, 0.5);
	\path [arrow] (0, 0.5) -- (-0.5, 0.5);
	
	\path [arrow, red] (3.5, 0) -- (3.5, -0.5);
	\path [arrow] (4, 0.5) -- (4.5, 0.5);
	\path [arrow] (3, 0.5) -- (2.5, 0.5);
	
	\path [arrow] (6.5, 1) -- (6.5, 1.5);
	\path [arrow, red] (7, 0.5) -- (7.5, 0.5);
	\path [arrow] (6.5, 0) -- (6.5, -0.5);
	
    \path [arrow] (9.5, 1) -- (9.5, 1.5);
	\path [arrow, red] (9, 0.5) -- (8.5, 0.5);
	\path [arrow] (9.5, 0) -- (9.5, -0.5);                                                                               
	
\end{tikzpicture}
\caption{Possíveis direções de movimento da serpente}
\label{fig:snakeHeadPositions}
\end{figure}

Considerando ainda a restrição de deslocamento na qual pode-se mover unicamente nas referidas direções, o cálculo por meio da distância de Manhattan se mostrou menos custoso, uma vez que a segunda equação, abaixo, não envolve operações quadráticas as quais podem ser chamadas inúmeras vezes por segundo.

\begin{equation}
EuclidianDistance = \sqrt{(x_{1} - x_{2})^2 + (y_{1} - y_{2})^2}
\end{equation} 

\begin{equation}
ManhattanDistance = \left|x_{1} - x_{2}\right| + \left|y_{1} - y_{2}\right|
\end{equation}

No que concerne a segunda camada, o \textit{shader} determina a relação de domínio (ou pertencimento) de todo pixel durante a execução do jogo, em outras palavras, verifica-se a que elemento gráfico cada pixel pertence, o que pode ser, no universo desta aplicação, o objeto coletável, ou uma parte da serpente ou ainda o próprio plano de fundo. Para determinar esta relação de atribuição, alguns cálculos básicos são necessários: um pixel é colorido com a cor do objeto coletável se sua distância até o centro do objeto for menor que o raio, semelhantemente mantem-se um vetor de pontos equidistantes entre si, onde cada posição representa um quadrilátero que faz parte do corpo da \textit{snake} e o mesmo pixel pode receber a cor da serpente, caso esteja contido na área destes quadriláteros, dados seu tamanho do lado e centros, no entanto, uma vez que não atenda a nenhum caso anterior, o pixel simplesmente recebe a cor do plano de fundo. 

É ainda no \textit{shader} que outra particularidade do jogo é atendida: a serpente move-se de maneira circular. Para este efeito, deve-se compreender o mapeamento UV, que consiste em projetar uma imagem 2D em uma superfície 3D, da superfície do objeto, neste caso, uma esfera. Basta verificar as extremidades para a presença da \textit{snake} e redesenhá-la no lado apropriado. 

O diagrama abaixo ilustra, de maneira geral, o funcionamento da arquitetura. 

\begin{figure}[H]
\centering
\tikzstyle{arrow} = [draw, -latex]

\begin{tikzpicture} [x=1.2cm, y=1cm, node distance=0,outer sep=0,inner sep=0]
	\draw (0, 0) rectangle (12,5);
	\draw[dashed] (6,0) -- (6,5);	
	
	\draw (0,4.5) rectangle (6,5) node[pos=.5] {\small Camada Lógica (CSharp)};
	\draw (6, 4.5) rectangle (12, 5) node[pos=.5] {\small Camada de Visualização (Shader)};
	
	\draw (0.3, 3.7) rectangle (4, 4.2) node[pos=.5] (1A) {\small Gerenciamento de Colisão};
	\draw (0.6, 2.9) rectangle (4.6, 3.4) node[pos=.5] (2A) {\small Movimentação da Serpente};
	\draw (7, 2.9) rectangle (11, 3.4)node[pos=.5] (3A) {\small Renderização da Serpente};
	
	\draw (0.3, 2) rectangle (4.3, 2.5) node[pos=.5] (4A) {\small Aplicação do filtro de Kalman};
	\draw (0.4, 1.2) rectangle (5.8, 1.7) node[pos=.5] (5A) {\small Cálculo da Geometria do Plano de Fundo};
	\draw (7, 1.2) rectangle (11.7, 1.7) node[pos=.5] (6A) {\small Renderização do Plano de Fundo};	
	
	\draw (0.3, 0.2) rectangle (5.9, 0.7) node[pos=.5] (7A) {\small Inteligência de Movimentação da Serpente};
	
	\path [arrow] (1A) -- (2A);
	\path [arrow] (2A) -- (3A);

	\path [arrow] (4A) -- (5A);
	\path [arrow] (5A) -- (6A);
\end{tikzpicture}
\caption{Diagrama de arquitetura da aplicação}
\label{fig:diagramaArquitetura}
\end{figure}

\section{Uso do Controle VR com Filtro de Kalman} \label{sec:gearvrcontroller}
Devido à natureza do jogo desenvolvido, o jogador necessita controlar o posicionamento do objeto coletável e para tanto existem essencialmente duas formas de interação com o cursor num dispositivo de realidade virtual: o HDM (\textit{head-mounted display}), ou seja, um sensor lateral acoplado ao próprio dispositivo, e os controladores externos, como os controles ou \textit{joysticks}. Em sua condição de sensor, porém, estes controladores estão sujeitos à interferência ruidosa durante a virtualização do evento representado no mundo real pelo movimento do usuário. Com a finalidade de melhorar a captura do sinal e traduzir de maneira mais fiel as intenções do jogador, o filtro de Kalman será aplicado às leituras do \textit{joystick} por meio de um componente de visualização de ruídos e aplicação do filtro desenvolvido por [], conforme apontado na figura \ref{fig:diagramaArquitetura}.

Cabe rememorar o conceito estabelecido pelo filtro de Kalman: trata-se de um filtro ótimo capaz de determinar estados passados e futuros de um sistema dinâmico linear, a partir de um grupo de entradas ruidosas, desde que tal ruído seja gaussiano. Para a efetiva implementação no controle de realidade virtual, inicialmente captura-se a orientação angular do \textit{joystick}, traça-se um raio da posição virtual atual do controle até uma esfera unitária e o ponto resultante da interseção é o foco do usuário, em outras palavras, o objetivo apontado pelo cursor, esta posição é onde aplica-se efetivamente o filtro de Kalman. 

\section{Resultados} \label{sec:results}

\section{Conclusão}\label{sec:conclusion}

% Resumo do artigo
Apresentou-se neste artigo uma implementação do filtro de Kalman para estabilização do controle de realidade virtual da Samsung. Concomitantemente, descreveu-se a visualização das entradas ruidosas fornecidas pelo controle e o efeito resultante após a aplicação do filtro. A fim de estimular a reutilização da implementações feitas, foram gerados componentes para rápida configuração e aplicação. Apresentou-se também a implementação do jogo \textit{VRSnake} para realidade virtual, construído sobre uma arquitetura que alivia a carga de trabalho atribuída à CPU, à medida que atribui à GPU o controle total sobre a renderização dos elementos dispostos no dispositivo de saída.

Através dos resultados obtidos, verificou-se que a solução desenvolvida em \textit{Unity} para a aplicação do filtro foi efetivamente capaz de filtrar as posições ruidosas geradas pelo controlador e garantir um nível de controle mais estável em aplicações de realidade virtual. Da mesma maneira, o objetivo inicial de aliviar o trabalho de renderização atribuído à CPU foi alcançado ao passo que a GPU tornou-se responsável por gerenciar os objetos bem como suas respectivas renderizações no dispositivo de saída.

% Trabalhos Futuros
Em trabalhos futuros, dois passos são percebidos como cruciais. Em primeiro lugar, migrar inteiramente os processos da camada lógica para a camada de visualização, na unidade gráfica de processamento, com o propósito de permitir o controle e exibição de um número representativamente maior de serpentes. Em segundo lugar, aplicar aprendizagem de máquina nesta camada, objetivando-se um comportamento de busca e desvio de obstáculos (como outras serpentes e seu próprio corpo) mais inteligente, por conseguinte, desafiador.

\section{References}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
